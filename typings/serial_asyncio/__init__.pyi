"""
This type stub file was generated by pyright.
"""

import asyncio
import os
import serial
import termios

"""\
Support asyncio with serial ports.

Posix platforms only, Python 3.5+ only.

Windows event loops can not wait for serial ports with the current
implementation. It should be possible to get that working though.
"""
__version__ = ...
class SerialTransport(asyncio.Transport):
    """An asyncio transport model of a serial communication channel.

    A transport class is an abstraction of a communication channel.
    This allows protocol implementations to be developed against the
    transport abstraction without needing to know the details of the
    underlying channel, such as whether it is a pipe, a socket, or
    indeed a serial port.


    You generally won’t instantiate a transport yourself; instead, you
    will call `create_serial_connection` which will create the
    transport and try to initiate the underlying communication channel,
    calling you back when it succeeds.
    """
    def __init__(self, loop, protocol, serial_instance) -> None:
        ...
    
    @property
    def loop(self): # -> Unknown | None:
        """The asyncio event loop used by this SerialTransport."""
        ...
    
    @property
    def serial(self): # -> Unknown | None:
        """The underlying Serial instance.

        Equivalent to get_extra_info("serial")
        """
        ...
    
    def get_extra_info(self, name, default=...): # -> Unknown | Any | None:
        """Get optional transport information.

        Currently only "serial" is available.
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def is_closing(self): # -> bool:
        """Return True if the transport is closing or closed."""
        ...
    
    def close(self): # -> None:
        """Close the transport gracefully.

        Any buffered data will be written asynchronously. No more data
        will be received and further writes will be silently ignored.
        After all buffered data is flushed, the protocol's
        connection_lost() method will be called with None as its
        argument.
        """
        ...
    
    def write(self, data): # -> None:
        """Write some data to the transport.

        This method does not block; it buffers the data and arranges
        for it to be sent out asynchronously.  Writes made after the
        transport has been closed will be ignored."""
        ...
    
    def can_write_eof(self): # -> Literal[False]:
        """Serial ports do not support the concept of end-of-file.

        Always returns False.
        """
        ...
    
    def pause_reading(self): # -> None:
        """Pause the receiving end of the transport.

        No data will be passed to the protocol’s data_received() method
        until resume_reading() is called.
        """
        ...
    
    def resume_reading(self): # -> None:
        """Resume the receiving end of the transport.

        Incoming data will be passed to the protocol's data_received()
        method until pause_reading() is called.
        """
        ...
    
    def set_write_buffer_limits(self, high=..., low=...): # -> None:
        """Set the high- and low-water limits for write flow control.

        These two values control when the protocol’s
        pause_writing()and resume_writing() methods are called. If
        specified, the low-water limit must be less than or equal to
        the high-water limit. Neither high nor low can be negative.
        """
        ...
    
    def get_write_buffer_size(self): # -> int:
        """The number of bytes in the write buffer.

        This buffer is unbounded, so the result may be larger than the
        the high water mark.
        """
        ...
    
    def write_eof(self):
        ...
    
    def abort(self): # -> None:
        """Close the transport immediately.

        Pending operations will not be given opportunity to complete,
        and buffered data will be lost. No more data will be received
        and further writes will be ignored.  The protocol's
        connection_lost() method will eventually be called.
        """
        ...
    
    def flush(self): # -> None:
        """ clears output buffer and stops any more data being written
        """
        ...
    
    if os.name == "nt":
        ...
    else:
        ...


async def create_serial_connection(loop, protocol_factory, *args, **kwargs): # -> tuple[SerialTransport, Unknown]:
    """Create a connection to a new serial port instance.

    This function is a coroutine which will try to establish the
    connection.

    The chronological order of the operation is:

    1. protocol_factory is called without arguments and must return
       a protocol instance.

    2. The protocol instance is tied to the transport

    3. This coroutine returns successfully with a (transport,
       protocol) pair.

    4. The connection_made() method of the protocol
       will be called at some point by the event loop.

    Note:  protocol_factory can be any kind of callable, not
    necessarily a class. For example, if you want to use a pre-created
    protocol instance, you can pass lambda: my_protocol.

    Any additional arguments will be forwarded to the Serial constructor.
    """
    ...

async def connection_for_serial(loop, protocol_factory, serial_instance): # -> tuple[SerialTransport, Unknown]:
    """Create a connection to the given serial port instance.

    This function is a coroutine which will try to establish the
    connection.

    The chronological order of the operation is:

    1. protocol_factory is called without arguments and must return
       a protocol instance.

    2. The protocol instance is tied to the transport

    3. This coroutine returns successfully with a (transport,
       protocol) pair.

    4. The connection_made() method of the protocol
       will be called at some point by the event loop.

    Note:  protocol_factory can be any kind of callable, not
    necessarily a class. For example, if you want to use a pre-created
    protocol instance, you can pass lambda: my_protocol.
    """
    ...

async def open_serial_connection(*, loop=..., limit=..., **kwargs): # -> tuple[StreamReader, StreamWriter]:
    """A wrapper for create_serial_connection() returning a (reader,
    writer) pair.

    The reader returned is a StreamReader instance; the writer is a
    StreamWriter instance.

    The arguments are all the usual arguments to Serial(). Additional
    optional keyword arguments are loop (to set the event loop instance
    to use) and limit (to set the buffer limit passed to the
    StreamReader.

    This function is a coroutine.
    """
    ...

if __name__ == '__main__':
    class Output(asyncio.Protocol):
        def __init__(self) -> None:
            ...
        
        def connection_made(self, transport): # -> None:
            ...
        
        def data_received(self, data): # -> None:
            ...
        
        def connection_lost(self, exc): # -> None:
            ...
        
        def pause_writing(self): # -> None:
            ...
        
        def resume_writing(self): # -> None:
            ...
        
    
    
    loop = ...
    coro = ...
